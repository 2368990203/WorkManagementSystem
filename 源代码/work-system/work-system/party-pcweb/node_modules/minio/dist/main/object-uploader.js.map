{"version":3,"sources":["object-uploader.js"],"names":[],"mappings":"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","file":"object-uploader.js","sourcesContent":["/*\n * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Transform } from 'stream'\nimport Crypto from 'crypto'\nimport * as querystring from 'querystring'\n\n// We extend Transform because Writable does not implement ._flush().\nexport default class ObjectUploader extends Transform {\n  constructor(client, bucketName, objectName, partSize, metaData, callback) {\n    super()\n    this.emptyStream = true\n    this.client = client\n    this.bucketName = bucketName\n    this.objectName = objectName\n    // The size of each multipart, chunked by BlockStream2.\n    this.partSize = partSize\n    // This is the metadata for the object.\n    this.metaData = metaData\n\n    // Call like: callback(error, etag).\n    this.callback = callback\n\n    // We need to keep track of what number chunk/part we're on. This increments\n    // each time _write() is called. Starts with 1, not 0.\n    this.partNumber = 1\n\n    // A list of the previously uploaded chunks, for resuming a file upload. This\n    // will be null if we aren't resuming an upload.\n    this.oldParts = null\n\n    // Keep track of the etags for aggregating the chunks together later. Each\n    // etag represents a single chunk of the file.\n    this.etags = []\n\n    // This is for the multipart upload request — if null, we're either not initiated\n    // yet or we're flushing in one packet.\n    this.id = null\n\n    // Handle errors.\n    this.on('error', err => {\n      callback(err)\n    })\n  }\n\n  _transform(chunk, encoding, callback) {\n    this.emptyStream = false\n    let method = 'PUT'\n    let headers = Object.assign({}, this.metaData, {'Content-Length': chunk.length})\n    let md5digest = ''\n\n    // Calculate and set Content-MD5 header if SHA256 is not set.\n    // This will happen only when there is a secure connection to the s3 server.\n    if (!this.client.enableSHA256) {\n      md5digest = Crypto.createHash('md5').update(chunk).digest()\n      headers['Content-MD5'] = md5digest.toString('base64')\n    }\n    // We can flush the object in one packet if it fits in one chunk. This is true\n    // if the chunk size is smaller than the part size, signifying the end of the\n    // stream.\n    if (this.partNumber == 1 && chunk.length < this.partSize) {\n      // PUT the chunk in a single request — use an empty query.\n      let options = {\n        method, headers,\n        query: '',\n        bucketName: this.bucketName,\n        objectName: this.objectName\n      }\n\n      this.client.makeRequest(options, chunk, 200, '', true, (err, response) => {\n        if (err) return callback(err)\n\n        let etag = response.headers.etag\n        if (etag) {\n          etag = etag.replace(/^\"/, '').replace(/\"$/, '')\n        }\n\n        // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)\n        response.on('data', () => {})\n\n        // Give the etag back, we're done!\n\n        process.nextTick(() => {\n          this.callback(null, etag)\n        })\n\n        // Because we're sure the stream has ended, allow it to flush and end.\n        callback()\n      })\n\n      return\n    }\n\n    // If we aren't flushing in one packet, we need to initiate the multipart upload,\n    // if it hasn't already been done. The write will be buffered until the upload has been\n    // initiated.\n    if (this.id === null) {\n      this.once('ready', () => {\n        this._transform(chunk, encoding, callback)\n      })\n\n      // Check for an incomplete previous upload.\n      this.client.findUploadId(this.bucketName, this.objectName, (err, id) => {\n        if (err) return this.emit('error', err)\n\n        // If no upload ID exists, initiate a new one.\n        if (!id) {\n          this.client.initiateNewMultipartUpload(this.bucketName, this.objectName, this.metaData, (err, id) => {\n            if (err) return callback(err)\n\n            this.id = id\n\n            // We are now ready to accept new chunks — this will flush the buffered chunk.\n            this.emit('ready')\n          })\n\n          return\n        }\n\n        this.id = id\n\n        // Retrieve the pre-uploaded parts, if we need to resume the upload.\n        this.client.listParts(this.bucketName, this.objectName, id, (err, etags) => {\n          if (err) return this.emit('error', err)\n\n          // It is possible for no parts to be already uploaded.\n          if (!etags) etags = []\n\n          // oldParts will become an object, allowing oldParts[partNumber].etag\n          this.oldParts = etags.reduce(function(prev, item) {\n            if (!prev[item.part]) {\n              prev[item.part] = item\n            }\n            return prev\n          }, {})\n\n          this.emit('ready')\n        })\n      })\n\n      return\n    }\n\n    // Continue uploading various parts if we have initiated multipart upload.\n    let partNumber = this.partNumber++\n\n    // Check to see if we've already uploaded this chunk. If the hash sums match,\n    // we can skip to the next chunk.\n    if (this.oldParts) {\n      let oldPart = this.oldParts[partNumber]\n\n      //Calulcate the md5 hash, if it has not already been calculated.\n      if(!md5digest) {\n        md5digest = Crypto.createHash('md5').update(chunk).digest()\n      }\n\n      if (oldPart && md5digest.toString('hex') === oldPart.etag) {\n        // The md5 matches, the chunk has already been uploaded.\n        this.etags.push({part: partNumber, etag: oldPart.etag})\n\n        callback()\n        return\n      }\n    }\n\n    // Write the chunk with an uploader.\n    let query = querystring.stringify({\n      partNumber: partNumber,\n      uploadId: this.id\n    })\n\n    let options = {\n      method, query, headers,\n      bucketName: this.bucketName,\n      objectName: this.objectName\n    }\n\n    this.client.makeRequest(options, chunk, 200, '', true, (err, response) => {\n      if (err) return callback(err)\n\n      // In order to aggregate the parts together, we need to collect the etags.\n      let etag = response.headers.etag\n      if (etag)\n        etag = etag.replace(/^\"/, '').replace(/\"$/, '')\n\n      this.etags.push({part: partNumber, etag})\n\n      // We're ready for the next chunk.\n      callback()\n    })\n  }\n\n  _flush(callback) {\n    if (this.emptyStream) {\n      let method = 'PUT'\n      let headers = Object.assign({}, this.metaData, {'Content-Length': 0})\n      let options = {\n        method, headers,\n        query: '',\n        bucketName: this.bucketName,\n        objectName: this.objectName\n      }\n\n      this.client.makeRequest(options, '', 200, '', true, (err, response) => {\n        if (err) return callback(err)\n\n        let etag = response.headers.etag\n        if (etag) {\n          etag = etag.replace(/^\"/, '').replace(/\"$/, '')\n        }\n\n        // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)\n        response.on('data', () => {})\n\n        // Give the etag back, we're done!\n        process.nextTick(() => {\n          this.callback(null, etag)\n        })\n\n        // Because we're sure the stream has ended, allow it to flush and end.\n        callback()\n      })\n\n      return\n    }\n    // If it has been uploaded in a single packet, we don't have to do anything.\n    if (this.id === null) {\n      return\n    }\n\n    // This is called when all of the chunks uploaded successfully, thus\n    // completing the multipart upload.\n    this.client.completeMultipartUpload(this.bucketName, this.objectName, this.id,\n                                        this.etags, (err, etag) => {\n                                          if (err) return callback(err)\n\n                                          // Call our callback on the next tick to allow the streams infrastructure\n                                          // to finish what its doing before we continue.\n                                          process.nextTick(() => {\n                                            this.callback(null, etag)\n                                          })\n\n                                          callback()\n                                        })\n  }\n}\n"]}